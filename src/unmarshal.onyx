package protobuf

use core {Result, tprintf}
use core.memory
use core.misc

Unmarshal_Error :: union {
    Err: str
    EOF: void
    Unexpected_EOF: void
    Unknown_Type: type_expr
    Unknown_Field: struct {
        name: str
        field: i32
    }
}

unmarshal :: (input: [] u8, $type: type_expr, allocator := context.allocator) -> Result(type, Unmarshal_Error) {
    val: type
    parse_message(input, &val, type)?

    return .{ Ok = ~~ val }
}


#local {

parse_message :: (input: [] u8, out: rawptr, type: type_expr) -> Result(bool, Unmarshal_Error) {
    if !registered_proto_types->has(type) do return .{ Err = .{ Unknown_Type = type } }

    data := input
    msg_desc := registered_proto_types->get_ptr(type)
    while data {
        field_header := parse_field_header(&data)?
        if field_header.encoding_type == .SGROUP || field_header.encoding_type == .EGROUP {
            continue
        }

        field_value := parse_field_value(&data, field_header.encoding_type)?

        maybe_field_desc := Slice.find_opt(
            msg_desc.fields
            [x](x.proto_field_number == field_header.proto_number)
        )

        if !maybe_field_desc do continue

        field_desc := maybe_field_desc!
        dest_ptr, dest_type := get_ptr_and_type(out, &field_desc)
        if dest_ptr == null do continue

        dest_type_info := dest_type->info()
        if dest_type == str {
            *cast(& str) dest_ptr = str.copy(field_value.bytes->expect("str should be encoded in len"))
        }
        elseif dest_type_info.kind == .Basic {
            if field_value.bytes {
                continue
            }

            store_basic_value(dest_ptr, dest_type, field_value.number->expect("primitives should be encoded in number"), field_desc.int_encoding)
        }
        elseif dest_type_info.kind == .Enum {
            *cast(& i32) dest_ptr = ~~ field_value.number->expect("enum should be encoded in number")
        }
        elseif dest_type_info.kind == .Struct {
            parse_message(field_value.bytes!, dest_ptr, dest_type)?
        }
    }

    return .{ Ok = true }
}



_Field_Header :: struct {
    proto_number: i32
    encoding_type: _Encoding_Type
}

_Field_Value :: union {
    number: u64
    bytes: [] u8
}



parse_field_header :: (data: &[] u8) -> Result(_Field_Header, Unmarshal_Error) {
    if data.length == 0 do return .{ Err = .EOF }

    b := parse_varint(data)?

    return .{
        Ok = .{
            ~~(b >> 3)
            ~~(b & 7)
        }
    }
}

parse_field_value :: (data: &[] u8, enc: _Encoding_Type) -> Result(_Field_Value, Unmarshal_Error) {
    switch enc {
        case .Varint {
            v := parse_varint(data)?
            return .{ Ok = .{ number = v } }
        }

        case .I64 {
            if data.length < 8 do return .{ Err = .Unexpected_EOF }

            v: &u64 = ~~ data.data
            str.advance(data, 8)

            return .{ Ok = .{ number = *v } }
        }

        case .I32 {
            if data.length < 4 do return .{ Err = .Unexpected_EOF }

            v: &u32 = ~~ data.data
            str.advance(data, 4)

            return .{ Ok = .{ number = ~~ *v } }
        }

        case .LEN {
            length := cast(u32) parse_varint(data)?
            if data.length < length do return .{ Err = .Unexpected_EOF }

            result := data.data[0 .. length]
            str.advance(data, length)

            return .{ Ok = .{ bytes = result } }
        }

        case _ {
            panic("UNHANDLED")
            return .{ Err = .Unexpected_EOF }
        }
    }
}

parse_varint :: (data: &[] u8) -> Result(u64, Unmarshal_Error) {
    out, shift: u64
    while true {
        if data.length == 0 do return .{ Err = .Unexpected_EOF }

        b := data.data[0]
        str.advance(data)

        out |= ~~(0x7f & b) << shift
        shift += 7
        
        if b & 0x80 == 0 {
            break
        }
    }

    return .{ Ok = out }
}

get_ptr_and_type :: (base: rawptr, field_desc: &Proto_Field_Descriptor) -> (out: rawptr, type: type_expr) {
    field_type_info := field_desc.field_type->info()
    switch field_type_info.kind {
        case .Basic, .Enum {
            out = memory.ptr_add(base, field_desc.field_offset)
            type = field_desc.field_type
        }

        case .Union {
            if field_type_info->as_union().constructed_from == Optional {
                *cast(& u8) memory.ptr_add(base, field_desc.field_offset) = ~~ Optional(void).tag_enum.Some
                out  = memory.ptr_add(base, field_desc.field_offset + field_type_info.alignment)
                type = field_type_info->as_union().variants[1].type
            }
        }

        case .Dynamic_Array {
            info := field_type_info->as_dynamic_array()
            type = info.of

            arr := cast(&Untyped_Array) memory.ptr_add(base, field_desc.field_offset)

            out = Array.untyped_alloc_one(arr, type)
            if out == null do break
        }
    }

    return
}

store_basic_value :: (out: rawptr, type: type_expr, value: u64, int_encoding: Int_Encoding) {
    switch type {
        case bool do *cast(& bool) out = value != 0

        case i32 do *cast(& i32) out = make_i32(value, int_encoding)
        case i64 do *cast(& i64) out = make_i64(value, int_encoding)

        case u32 do *cast(& u32) out = ~~ value
        case u64 do *cast(& u64) out = value

        case f32 {
            tmp := value
            *cast(& i32) out = *cast(& i32) &tmp
        }

        case f64 {
            tmp := value
            *cast(& i64) out = *cast(& i64) &tmp
        }

        case _ {
            panic(tprintf("Unsupported basic type: '{}'", type))
        }
    }

    make_i32 :: (value: u64, int_encoding: Int_Encoding) -> i32 {
        switch int_encoding {
            case .Twos_Complement, .Fixed {
                return cast(u32) value
            }

            case .Zig_Zag {
                if value & 1 == 0 {
                    return cast(i32) (value >> 1)
                } else {
                    return -cast(i32) (value >> 1) - 1
                }
            }
        }

        return 0
    }

    make_i64 :: (value: u64, int_encoding: Int_Encoding) -> i64 {
        switch int_encoding {
            case .Twos_Complement, .Fixed {
                return value
            }

            case .Zig_Zag {
                if value & 1 == 0 {
                    return cast(i64) (value >> 1)
                } else {
                    return -cast(i64) (value >> 1) - 1
                }
            }
        }

        return 0
    }
}



use core.array { Untyped_Array }

Array.untyped_alloc_one :: (arr: &Untyped_Array, type: type_expr) -> rawptr {
    element_size := type->info().size

    if arr.count >= arr.capacity {
        if arr.capacity == 0 {
            arr.capacity = 4
            arr.allocator = context.allocator
        } else {
            arr.capacity <<= 1
        }

        new_data := raw_resize(arr.allocator, arr.data, element_size * arr.capacity)
        if new_data == null do return null
        arr.data = new_data

        memory.set(memory.ptr_add(arr.data, element_size * arr.count), 0, element_size * arr.capacity)
    }

    defer arr.count += 1
    return memory.ptr_add(arr.data, element_size * arr.count)
}

}
