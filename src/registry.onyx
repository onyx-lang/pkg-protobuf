package protobuf

use core {Result, tprintf}
use core.memory
use core.misc
use runtime.info

#package {
    registered_proto_types: Map(type_expr, Proto_Message_Descriptor)
}

proto_types_preloaded :: #init () {
    registered_proto_types->init()

    for info.type_table {
        if it.info.kind != .Struct do continue

        struct_info := it.info->as_struct()
        if !Slice.some(struct_info.tags, [x](x.type == type_expr && *cast(&type_expr, x.data) == Message)) {
            continue
        }

        fields := make([] Proto_Field_Descriptor, struct_info.members.length)
        for member, index in struct_info.members {
            fields[index].field_offset = member.offset

            type_info := member.type->info()
            switch type_info.kind {
                case .Basic {
                    fields[index].field_type_ = member.type
                }

                case .Dynamic_Array {
                    fields[index].field_type_ = type_info->as_dynamic_array().of
                    fields[index].is_repeated = true
                }

                case .Union {
                    if type_info->as_union().constructed_from == Optional {
                        fields[index].field_type_ = type_info->as_union().variants[1].type
                        fields[index].is_optional = true
                        fields[index].optional_offset = ~~ type_info.alignment
                    }
                }
            }

            member.tags
                |> .find_opt([x](x.type == Field))
                |> .transform(x => *misc.any_as(x, Field))
                |> .with([fi] {
                    fields[index].proto_field_type   = ~~ fi.protobuf_type 
                    fields[index].proto_field_number = fi.number
                })
        }

        register_proto_type(it.type, .{ fields })
    }
}

register_proto_type :: (type: type_expr, desc: Proto_Message_Descriptor) {
    registered_proto_types->put(type, desc)
}

